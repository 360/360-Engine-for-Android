/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the Common Development
 * and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at
 * src/com/vodafone360/people/VODAFONE.LICENSE.txt or
 * http://github.com/360/360-Engine-for-Android
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each file and
 * include the License file at src/com/vodafone360/people/VODAFONE.LICENSE.txt.
 * If applicable, add the following below this CDDL HEADER, with the fields
 * enclosed by brackets "[]" replaced with your own identifying information:
 * Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2010 Vodafone Sales & Services Ltd.  All rights reserved.
 * Use is subject to license terms.
 */

package com.vodafone360.people.datatypes;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.vodafone360.people.engine.presence.User;
import com.vodafone360.people.utils.LogUtils;

/**
 * BaseDataType encapsulating presence list. This is a list of the online
 * statuses for a list of contacts specified by user id. Each contact may have
 * statuses for a number of online communities specified (i.e. Facebook, Google,
 * MSN etc.). TODO: it doesn't have to be the BaseDataType
 */
public class PresenceList extends BaseDataType {

    public final static String NAME = "PresenceList";

    private long mUserId; // "myself"

    private String mType;

    private List<User> users; // The contact list of not offline users.

    /**
     * //////////////////////////////ServiceMethods/////////////////////////////
     */

    /**
     * Create PresenceList from Hashtable generated by Hessian-decoder
     * 
     * @param hash Hashtable containing PresenceList parameters
     */
    public void createFromHashtable(Hashtable<String, Object> hash) {
        LogUtils.logI("HessianDecoder.createFromHashtable() hash[" + hash.toString() + "]");
        Enumeration<String> e = hash.keys();
        while (e.hasMoreElements()) {
            String key = e.nextElement();
            LogUtils.logI("HessianDecoder.createFromHashtable() key[" + key + "] value["
                    + hash.get(key) + "]");
            Tags tag = Tags.findTag(key);
            if (tag != null) {
                setValue(tag, hash.get(key));
            }
        }

        LogUtils.logI("HessianDecoder.createFromHashtable() mUserId[" + mUserId + "] mType["
                + mType + "] users[" + users + "]");
        if (users != null) {
            for (User mUser : users) {
                LogUtils.logI("HessianDecoder.createFromHashtable() getPayload["
                        + mUser.getPayload() + "]");
            }
        } else {
            LogUtils.logW("HessianDecoder.createFromHashtable() users is NULL");
        }
    }

    private void setValue(Tags key, Object value) {
        LogUtils.logI("HessianDecoder.setValue() key[" + key + "] value[" + value + "]");
        switch (key) {
            case USER_ID:
                mUserId = (Long)value;
                break;

            case TYPE:
                mType = (String)value;
                break;

            case PAYLOAD:
                LogUtils.logW("HessianDecoder.setValue() PAYLOAD mType[" + mType + "]");
                @SuppressWarnings("unchecked")
                Hashtable<String, Object> mPayload = (Hashtable<String, Object>)value;

                Set<Map.Entry<String, Object>> set = mPayload.entrySet();
                for (Map.Entry<String, Object> obj : set) {
                    @SuppressWarnings("unchecked")
                    User mUser = new User(obj.getKey(), (Hashtable<String, String>) obj.getValue());
                    if (users == null) {
                        users = new ArrayList<User>();
                    }
                    users.add(mUser);
                }

                break;
            default:
                LogUtils.logE("HessianDecoder.setValue() key[" + key + "] value[" + value + "]");
        }
    }

    @Override
    public String name() {
        return NAME;
    }

    private enum Tags {
        USER_ID("userid"),
        TYPE("type"),
        PAYLOAD("payload");

        private final String mTag;

        private Tags(String tag) {
            mTag = tag;
        }

        private String tag() {
            return mTag;
        }

        private static Tags findTag(String tag) {
            for (Tags tags : Tags.values()) {
                if (tag.compareTo(tags.tag()) == 0) {
                    return tags;
                }
            }
            return null;
        }
    }

    /**
     * /////////////End Of Service Methods///////////////
     */

    /**
     * The presence list of not offline users.
     */
    public List<User> getUsers() {
        return users;
    }

    // /**
    // * This method is called by the Engine to update the presence list state
    // and refresh user statuses
    // * @param changes is a Hashtable<String - UserId, Hashtable -
    // presenceStatus in communities>
    // */
    // @SuppressWarnings("unchecked")
    // public void addUsers(List<User> changes) {
    // if (changes != null) {
    // for (User user: changes) {
    // if (users.contains(user))
    // users.remove(user);
    // if (user.isOnline() != OnlineStatus.OFFLINE.ordinal())
    // users.add(user);
    // }
    // }
    // }

    @Override
    public String toString() {
        StringBuffer mOutput = new StringBuffer();
        mOutput.append("PresenceList - mUserId[" + mUserId + "] mType[" + mType + "] users[");
        if (users != null) {
            for (User user : users) {
                mOutput.append("[" + user.toString() + "]");
            }
        }
        mOutput.append("]");
        return mOutput.toString();
    }
}
